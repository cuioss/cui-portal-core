= Portal Authentication API

Provides a comprehensive API for authentication and authorization in Portal applications, serving as an abstraction layer over various authentication mechanisms.

== Maven Coordinates

[source, xml]
----
    <dependency>
        <groupId>de.cuioss.portal.authentication</groupId>
        <artifactId>portal-authentication-api</artifactId>
    </dependency>
----

== Core Concepts

=== Authentication Model
* User identity management through link:src/main/java/de/cuioss/portal/authentication/AuthenticatedUserInfo.java[AuthenticatedUserInfo]
* Immutable user state with link:src/main/java/de/cuioss/portal/authentication/model/BaseAuthenticatedUserInfo.java[BaseAuthenticatedUserInfo]
* Extensible attribute system for custom data
* Role and group-based authorization

=== Authentication Facade
* Unified authentication interface through link:src/main/java/de/cuioss/portal/authentication/facade/AuthenticationFacade.java[AuthenticationFacade]
* Session management and logout handling
* Authentication source tracking
* Pluggable authentication mechanisms

=== User Enrichment
* Extensible user information through link:src/main/java/de/cuioss/portal/authentication/PortalUserEnricher.java[PortalUserEnricher]
* Priority-based enrichment chain
* Custom attribute addition
* Dynamic user context updates

== Authentication Flow

=== 1. Initial Authentication
[source,java]
----
@Inject
private AuthenticationFacade authFacade;

public void login(Credentials credentials) {
    AuthenticationResult result = authFacade.authenticate(credentials);
    if (result.isValid()) {
        AuthenticatedUserInfo user = result.getUserInfo();
        // Process authenticated user
    }
}
----

=== 2. User Information Access
[source,java]
----
@Inject
private AuthenticatedUserInfo userInfo;

public void processUser() {
    if (userInfo.isAuthenticated()) {
        String userId = userInfo.getIdentifier();
        String displayName = userInfo.getDisplayName();
        Set<String> roles = userInfo.getRoles();
        
        // Access custom attributes
        Optional<String> department = userInfo.getAttributeValue("department");
    }
}
----

=== 3. Authorization Checks
[source,java]
----
@Inject
private AuthenticatedUserInfo userInfo;

public void restrictedOperation() {
    if (!userInfo.isAuthenticated()) {
        throw new SecurityException("Authentication required");
    }
    
    if (!userInfo.isUserInRole("ADMIN")) {
        throw new SecurityException("Admin access required");
    }
    
    // Perform restricted operation
}
----

=== 4. User Enrichment
[source,java]
----
@Priority(PortalPriorities.PORTAL_CORE_LEVEL)
public class DepartmentEnricher implements PortalUserEnricher {
    
    @Override
    public AuthenticatedUserInfo enrich(AuthenticatedUserInfo userInfo) {
        return BaseAuthenticatedUserInfo.builder()
            .copyFrom(userInfo)
            .addAttribute("department", loadDepartment(userInfo))
            .build();
    }
}
----

== Package Structure

=== link:src/main/java/de/cuioss/portal/authentication[authentication]
Core authentication interfaces and base types.

=== link:src/main/java/de/cuioss/portal/authentication/model[model]
User information model and storage implementations.

=== link:src/main/java/de/cuioss/portal/authentication/facade[facade]
Authentication facade and related services.

== Best Practices

=== User Information Handling
* Always use builder pattern for creating user information
* Keep user information immutable
* Use Optional for optional attributes
* Handle authentication state explicitly

=== Authentication Implementation
* Extend BaseAuthenticationFacade for custom authentication
* Implement proper logout cleanup
* Track authentication sources
* Handle session timeouts gracefully

=== Security Considerations
* Validate all user input
* Use proper password handling
* Implement proper session management
* Follow least privilege principle
* Log security-relevant events

=== Thread Safety
* All components are thread-safe by design
* User information is immutable
* Facade implementations are CDI-managed
* Enrichers should be stateless

== Related Documentation

* link:https://jakarta.ee/specifications/security/[Jakarta Security]
* link:https://jakarta.ee/specifications/cdi/[Jakarta CDI]
* link:../portal-authentication/[Portal Authentication Implementations]